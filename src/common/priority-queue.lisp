(in-package #:%syntex.priority-queue)

(deftype data () '(simple-array t))

(declaim (inline %make-queue))
(defstruct (queue
            (:constructor %make-queue)
            (:conc-name nil)
            (:predicate nil)
            (:copier nil))
  (data (make-array 256) :type data)
  (priorities (make-array 256 :element-type 'u:f32) :type u:f32a)
  (size 0 :type u:array-length))

(u:define-printer (queue stream)
  (format stream "(~d)" (size queue)))

(u:fn-> make-queue (&key (:initial-size u:array-index)) queue)
(declaim (inline make-queue))
(defun make-queue (&key (initial-size 256))
  (declare (optimize speed))
  (%make-queue :data (make-array initial-size)
               :priorities (make-array initial-size :element-type 'u:f32)))

(u:fn-> copy (queue) queue)
(defun copy (queue)
  (declare (optimize speed))
  (%make-queue :size (size queue)
               :data (copy-seq (data queue))
               :priorities (copy-seq (priorities queue))))

(u:fn-> heapify-up (data u:f32a u:array-length) null)
(declaim (inline heapify-up))
(defun heapify-up (data priorities index)
  (declare (optimize speed))
  (do ((child-index index parent-index)
       (parent-index (ash (1- index) -1) (ash (1- parent-index) -1)))
      ((zerop child-index))
    (let ((child-priority (aref priorities child-index))
          (parent-priority (aref priorities parent-index)))
      (cond ((< child-priority parent-priority)
             (rotatef (aref priorities parent-index)
                      (aref priorities child-index))
             (rotatef (aref data parent-index)
                      (aref data child-index)))
            (t (return))))))

(u:fn-> enqueue (queue t u:f32) null)
(declaim (inline enqueue))
(defun enqueue (queue object priority)
  (declare (optimize speed))
  (symbol-macrolet ((data (data queue))
                    (priorities (priorities queue)))
    (let ((size (size queue))
          (length (length data)))
      (when (>= size length)
        (let ((new-length (max 1 (mod (* length 2) #.(ash 1 64)))))
          (declare (type u:array-length new-length))
          (setf data (adjust-array data new-length)
                priorities (adjust-array priorities new-length))))
      (setf (aref data size) object
            (aref priorities size) priority)
      (heapify-up data priorities size)
      (incf (size queue))
      nil)))

(u:fn-> heapify-down (data u:f32a u:array-index) null)
(declaim (inline heapify-down))
(defun heapify-down (data priorities size)
  (declare (optimize speed))
  (let ((parent-index 0))
    (flet ((swap-left (parent-index left-index)
             (rotatef (aref priorities parent-index)
                      (aref priorities left-index))
             (rotatef (aref data parent-index)
                      (aref data left-index))
             left-index)
           (swap-right (parent-index right-index)
             (rotatef (aref priorities parent-index)
                      (aref priorities right-index))
             (rotatef (aref data parent-index)
                      (aref data right-index))
             right-index))
      (declare (inline swap-left swap-right))
      (loop
        (let* ((left-index (+ (* parent-index 2) 1))
               (left-index-valid-p (< left-index size))
               (right-index (+ (* parent-index 2) 2))
               (right-index-valid-p (< right-index size)))
          (when (and (not left-index-valid-p)
                     (not right-index-valid-p))
            (return))
          (let ((parent-priority (aref priorities parent-index))
                (left-priority (aref priorities left-index))
                (right-priority (aref priorities right-index)))
            (when (and left-index-valid-p
                       (< parent-priority left-priority)
                       (or (not right-index-valid-p)
                           (< parent-priority right-priority)))
              (return))
            (if (and right-index-valid-p
                     (<= right-priority left-priority))
                (setf parent-index (swap-right parent-index right-index))
                (setf parent-index (swap-left parent-index left-index)))))))))

(u:fn-> dequeue (queue) (values t boolean))
(declaim (inline dequeue))
(defun dequeue (queue)
  (declare (optimize speed))
  (if (zerop (size queue))
      (values nil nil)
      (let ((data (data queue))
            (priorities (priorities queue)))
        (multiple-value-prog1 (values (aref data 0) t)
          (decf (size queue))
          (let ((size (size queue)))
            (setf (aref data 0) (aref data size)
                  (aref priorities 0) (aref priorities size)))
          (heapify-down data priorities (size queue))))))

(u:fn-> peek (queue) (values t boolean))
(declaim (inline peek))
(defun peek (queue)
  (declare (optimize speed))
  (if (zerop (size queue))
      (values nil nil)
      (values (aref (data queue) 0) t)))
